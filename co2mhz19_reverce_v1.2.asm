; Имя файла: co2_mh_z19_v1.0.asm
; Created: 11.02.2020 22:16
; Modified: 26.04.20, 04.05.20, 05.05.20, 09.05.20,
; Author : Игорь
; Для AVR: ATtiny4313 (ATtiny2313)                                                     
; Тактовая частота: 8 Мгц                                                

; Выполняемые функции:
; 1. Получение значения атмосферного давления от датчика LPS331AP по TWI интерфейсу.
; 2. Получение значения содержания СО2 в воздухе от датчика Mh-z19b по интерфейсу UART.
; 3. Получение значения температуры от датчика DS18B20 по интерфейсу 1-wire. 
; 4. Инидкация значения атмосферного давления и содержания СО2 на 2-х четырехразрядных 
;    семимегментных индикаторах, програмная реализация интерфейса передачи SPI на индикаторы.
; 5. Попеременная индикация температуры в помещении и атмосферного давления на верхнем индикаторе.
; 6. Изменен порядок включения индикаторов на обратный для в соответствии со схемой платы
;
; Назначение выводов МК:
; Подключение сдвиговых регистров 7-сегм индикаторов
; PB0- MO->SI (SER) (14): данные.
; PB1- DO->RCK (RCLK) (12): защелка.
; PB2- SCK->SRCLK (11): тактовый сигнал (прграммный).
;
; Подключение датчика СО2 MH-Z19B по интерфейсу UART (логика 3,3 В):
; PD0- RXD->TX (подкл. через транзистор, логика 3,3 В).
; PD1- TXD->RX (подкл. через транзистор, логика 3,3 В).
;
; Подключение датчика LPS331AP по интерфейсу TWI:
; PD6- SDA-> вход/выход данных LPS331AP.
; PD2- SCL-> выход тактового сигнала TWI.
;
; Подключение датчика температуры  DS18B20 по 1-Wire
; PB3- 1-Wire.
; PB4- отключение питания датчика температуры.
; 
; SPI для внутрисхемного программирования
; PB5- MOSI
; PB6- MISO
; PB7- SCK
;
; Светодиоды для контроля обмена данными с датчиками:
; PB7- контроль TWI.
; PD3- контроль UART RX.
; PD4- контроль UART TX.
; PD5- контроль 1-Wire.

.nolist
.include	"./include/tn2313def.inc"
.list

; Объявления =============================================================================================
.equ	AtBCD0 = 13           ; Adress of tBCD0
.equ	AtBCD2 = 15           ; Adress of tBCD1

.def	tBCD0 = r13           ; BCD value digits 1 and 0
.def	tBCD1 = r14           ; BCD value digits 3 and 2
.def	tBCD2 = r15           ; BCD value digits 4
.def	fbinL = r16           ; Binary value Low byte
.def	fbinH = r17           ; Binary value High byte
.def	cnt16a = r18          ; Loop counter
.def	tmp16a = r19          ; temporary value
.def	temp1 = r22           ; Буфер 1
.def	temp = r23            ; Буфер 0
.def	tx_rx_count = r20     ; Счетчик количества переданных битов по 1-wire
.def	data_in_out = r21     ; Передаваемое/принимаемое значение по 1-wire 

; RAM =====================================================================================================
	.DSEG								
	.ORG	SRAM_START		
count1:            .byte  1        ; Задержка 1 (период запроса данных от датчиков)
count2:            .byte  1        ; Коэф. 2 задержки 1 
delay1:            .byte  1        ; Коэффициент для задержки 1
delay2:            .byte  1        ; Коэффициент 2 для задержки 1
digit:             .byte  1        ; Число, передаваемое на индикатор (распакованные 8 бит)
ldigit:            .byte  1        ; Младший распакованный полубайт tBCD
hdigit:            .byte  1        ; Старший распакованный полубайт tBCD
led_counter:       .byte  1        ; Счетчик какой индикатор необходимо включить
flag_ex_stage:     .byte  1        ; Регистр флагов этапа измерения температуры DS18B20
tx_skip_ident:     .byte  1        ; Команда 0xCC к DS18B20 "Пропуск идентификации"
tx_start_conv:     .byte  1        ; Команда 0x44 к DS18B20 "Начало преобразования температуры"
tx_request_temp:   .byte  1        ; Команда 0xBE к DS18B20 "Запрос на получение значения температуры"
ltemperature:      .byte  1        ; Младший байт значения температуры от DS18B20
htemperature:      .byte  1        ; Старший байт значения температуры от DS18B20              
negative_temp:     .byte  1        ; Код знака минус
integer_temp:      .byte  1        ; Целая часть значение температуры
indication_sign:   .byte  1        ; Выводимое на индикатор значение знака температуры
rx_uart_mhz:       .byte  9        ; Регистры для хранения полученных байт от MH-Z19
checksum_calk:     .byte  1        ; Регистр для сохранения рассчитанногог знач. контр. суммы
lco2:              .byte  1        ; Младший регистр для хранения значения концентрации СО2
hco2:              .byte  1        ; Старший регистр для хранения значения концентрации СО2
count_rx_uart:     .byte  1        ; Счетчик полученных байт по UART
count_tx_uart:     .byte  1        ; Счетчик переданных по UART байт
flag_MH_init:      .byte  1        ; Флаг необходимости установки диапазона MH-Z19
press_twi:         .byte  3        ; Регистры для хранения знач. давл. от LPS331AP (POUT_XL,POUT_L,POUT_H)
lpress:            .byte  1        ; Младший байт для хранения значения давления
hpress:            .byte  1        ; Старший байт для хранения значения давления
sad_w:             .byte  1        ; Команда адреса датчика LPS331AP+ запись байта
sad_r:             .byte  1        ; Команда адреса датчика LPS331AP+ чтение байта
twi_sub:           .byte  1        ; Команда адреса ячейки памяти датчика LPS331AP для чтения
addr_uart_set:     .byte  2        ; Адрес строки для передачи команды установки диапазона MHZ19
choice_ind:        .byte  1        ; Выбор индикации верхнего индикатора

; FLASH ===================================================================================================
	.CSEG	
    rjmp    RESET                  ; 0x0000 Переход на начало программы
    reti    ;rjmp    INT0          ; 0x0001 External Interrupt Request 0
    reti    ;rjmp    INT1          ; 0x0002 External Interrupt Request 1
    reti    ;rjmp    ICP1          ; 0x0003 Timer/Counter1 Capture Event
    reti    ;rjmp    OC1A          ; 0x0004 Timer/Counter1 Compare Match A
    rjmp    OVF1                   ; 0x0005 Timer/Counter1 Overflow
    rjmp    OVF0                   ; 0x0006 Timer/Counter0 Overflow
    rjmp    RX_UART                ; 0x0007 USART, Rx Complete
    rjmp    TX_UART                ; 0x0008 UDRE Data register empty
    reti    ;rjmp    TX_UART                ; 0x0009 USART, Tx Complete
    reti    ;rjmp    ANALOG_COMP   ; 0x000A Analog Comparator 
    reti    ;rjmp    PCINT         ; 0x000B Pin change interrupt
    reti    ;rjmp    TIMER1_COMPB  ; 0x000C T1 compare match B
    reti    ;rjmp    TIMER0_COMPA  ; 0x000D T0 compare match A
    reti    ;rjmp    TIMER0_COMPB  ; 0x000E T0 compare match B
    reti    ;rjmp    USI_START     ; 0x000F USI start
    reti    ;rjmp    USI_OVF       ; 0x0010 USI overflow
    reti    ;rjmp    EE_READY      ; 0x0011 EEPROM ready
    reti    ;rjmp    WDT_OVF       ; 0x0012 Watchdog timer overflow
									
; Init ===================================================================================================
RESET:
    ldi    temp, 0xFF              ; Сбрасываем все флаги прерываний в единицу
    out    EIFR, temp              ; Индикация флагов внешних прерваний
    out    TIFR, temp              ; Флаги совпадения счетчика таймера Т1: 1А, 1В, 1С

    ldi    temp, 0b10010111        ; На выход PB0->MOSI, PB1->RCLK (защелка SPI), PB2->SRCLK (такт. SPI)
    out    DDRB, temp              ; PB7-> индикация TWI. На вход: PB5, PB6, PB3->DA (1-Ware)
	
    ldi    temp, 0b00000000        ; Выходы при включении в "0" кроме выходов TWI, которые в "1"
    out    PortB, temp             ; Подт. резист. не подключаем (предусмотреть в схеме)

    ldi    temp, 0b01111110        ; На выход PD2-> SCL (TWI), PD6-> SDA (TWI),
    out    DDRD, temp              ; PD3, PD4, PD5 индикация обмена данными с датчиками

    ldi    temp, 0b01000110        ; Выходы  PD3, PD4, PD6 при включении в "0" 
    out    PortD, temp             ; Выходы TWI-> PD2, PD6 при включении в "1"

    ldi    temp, 0b00000101        ; Источник тактового сигнала, значение предделителя clk_i.o/1024
    out    TCCR0B, temp            ; Записываем конфигурационные биты в управляющий
                                   ; регистр таймера/счетчика Т0
	
    ldi    temp, 250               ; Задержка 1 (период опроса датчика температуры ~8 c.)
    sts    count1, temp            ; Первоначальная инициализация таймера 1
    sts    delay1, temp            ; Значение коэффициента задержки таймера 1
    
    ldi    temp, 122               ; Задержка 2 (ожидание окончания преобразования температуры DS18B20)
    sts    delay2, temp            ; 16 битный счетчик без предделителя, задержка 0,99 с
    sts    count2, temp            ; Сохраняем коэф.2 задержки таймера 1

    ldi    temp, 0b01000000        ; Код 7-сегментного индикатора для отображения
    sts    negative_temp, temp     ; знака "-"

    ldi    temp, 0x00              ; Выбор выведения на индикатор давления
    sts    choice_ind, temp        ; 

    clr    fbinL                   ;
    clr    fbinH                   ;
    
    ldi    temp, 0                 ; Обнуление регистров флагов этапа получения значения
    sts    flag_ex_stage, temp     ; температуры от датчика DS18B20
    sts    integer_temp, temp      ;
    sts    indication_sign, temp   ;
    sts    ltemperature, temp
    sts    htemperature, temp
    sts    count_tx_uart, temp     ; Обнуление счетчика переданных/принятых байт для MH-Z19
    sts    count_rx_uart, temp     ;

    ldi    temp, 1                 ; Значение при инициализации о необходимости установки
    sts    flag_MH_init, temp      ; диапазона измерения MH-Z19

    ldi    temp, 0xCC              ; Сохраняем в переменной команду пропуска идентификации DS18B20
    sts    tx_skip_ident, temp     ;
    ldi    temp, 0x44              ; Сохраняем в переменной команду начала преобразования температуры
    sts    tx_start_conv, temp     ; датчиком DS18B20
    ldi    temp, 0xBE              ; Сохраняем в переменной команду запроса на получение значения
    sts    tx_request_temp, temp   ; температуры от датчика DS18B20

    ldi    temp, 0xb8              ; Команда SAD+W для LPS331AP (адрес датчика с битом записи)
    sts    sad_w, temp             ;
    ldi    temp, 0xb9              ; Команда SAD+R для LPS331AP (адрес датчика с битом чтения)
    sts    sad_r, temp             ;
    ldi    temp, 0xA8              ; Команда для LPS331AP (адрес ячейки памяти для чтения)
    sts    twi_sub, temp           ;

Uart_init:
    ldi     temp, 0x00
    out     UCSRB, temp         ; Запрещаем прием/передачу, прерывания по переполнению

    ldi     temp, 0b10000110
    out     UCSRC, temp            ; Формат кадра- 8 бит

    ldi     temp, 0x33
    out     UBRRL, temp            ;

    ldi     temp, 0x00             ; Обнуляем UCSRA, без удвоения скорости обмена
    out     UCSRA, temp            ;
    out     UBRRH, temp            ;
    
; TWI init LPS331AP
    sbi     PORTB, 7               ; Включение светодиода индикации передачи данных по TWI
    rcall   Start_TWI              ; Старт на шину TWI

    lds     data_in_out, sad_w     ; Загружаем команду SAD+W в регистр РОН ввода/вывода
    rcall   TWI_Write
    rcall   Sak_TWI

    ldi     data_in_out, 0x20      ; Загружаем адрес конфигурационнй ячейки LPS331AP
    rcall   TWI_Write              ; CTRL_REG1
    rcall   Sak_TWI                ;

    ldi     data_in_out, 0b10010000 ; Загружаем значение конфигурационных битоа 
    rcall   TWI_Write               ; измерение давления раз а секунду
    rcall   Sak_TWI
    rcall   Stop_TWI                ; 
    cbi    PORTB, 7                ; Отключаем светодиод и ндикации передачи данных
    
    ldi    temp, 0b00000010        ; Разрешение прерывания по переполнению таймера Т0
    OUT    TIMSK, temp             ;

    ldi    temp, low(RAMEND)       ; Main program start
    out    SPL, temp               ; Set Stack Pointer to top of RAM
    sei                            ; Enable interrupts

; ===========================================================================================================
; Основное тело программы
Main:
    rcall    Decoder_BCD           ; Вызов подпрограммы подготовки и передачи данных на индикатор
    rjmp     Flag                  ; Вызов подпрограммы обработки этапа получения данных от DS18B20
    rjmp     Main                  ; Возвращаемся к метке начала программы

; ==========================================================================================================
; Маска кодов семисегментного индикатора
N_Mask:
.db 0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f

;===========================================================================================================
; Маска команды установки диапазона измерения датчика MH-Z19B
; для диапазона 2000 PPM 6-й бит: 0x07, 7-й бит: 0xD0, 8-й бит: 0x8F
; для диапазона 3000 PPM 6-й бит: 0x0B, 7-й бит: 0xB7, 8-й бит: 0xA3
; для диапазона 5000 PPM 6-й ьит: 0x13, 7-й бит: 0x88, 8-й бит: 0xCB
MHZ_range_set:
.db 0xFF,0x01,0x99,0x00,0x00,0x00,0x13,0x88,0xCB,0xee

;===========================================================================================================
; Команда для чтения значения содержания СО2 из датчика MH-Z19
MHZ_co2_read:
.db 0xFF,0x01,0x86,0x00,0x00,0x00,0x00,0x00,0x79,0xee

; ===========================================================================================================
; Обработка прерывания переполнения таймера счетчика Т0
OVF0:
    PUSH    temp                ; Сохраняем значения временных переменных
    in      temp, SREG		;
    PUSH    temp                ;

    lds     temp, count1        ;
    dec     temp                ; Уменьшаем значение счетчика задержки 1
    sts     count1, temp        ;

    POP     temp                ; Восстанавливаем значение временных переменных
    out     SREG, temp          ;
    POP     temp                ;
    reti

; ===========================================================================================================
; Обработка прерывания переполнения таймера счетчика Т1
OVF1:
    PUSH    temp                ; Сохраняем значения временных переменных
    in      temp, SREG		;
    PUSH    temp                ;

    lds     temp, count2        ;
    dec     temp                ; Уменьшаем значение счетчика задержки 2
    sts     count2, temp        ;
   
    POP     temp                ; Восстанавливаем значение временных переменных
    out     SREG, temp          ;
    POP     temp                ;
    reti

;===========================================================================================================
; Обработка прерывания на прием по UART
RX_UART:
    sbi     PORTD, 3            ; Вкл. светодиода индикации приема данных по UART
    PUSH    temp                ; Сохраняем значения временных переменных
    PUSH    temp1               ;
    in      temp, SREG		;
    PUSH    temp                ;
    in      temp1, UDR          ; Достаем байт из UDR

    ldi     ZH, HIGH (rx_uart_mhz) ; Загружаем адрес переменной для хранения данных от MH-Z19B
    ldi     ZL, LOW (rx_uart_mhz)  ;
    lds     temp, count_rx_uart      ; Прибавляем к адресу начала переменной значение счетчика 
    add     ZL, temp                 ; принимаемого байта
    ldi     temp, 0                  ; Обнуляем значение регистра для сложения с переносом
    adc     ZH, temp                 ; Прибавляем к адресу только перенос
    st      Z, temp1            ; Сохраняем принятый байт в соответсвующем байте rx_uart_mhz

    lds     temp, count_rx_uart ; Увеличение значения счетчика номера принятого байта по UART
    inc     temp                ; 
    sts     count_rx_uart, temp ;

    cpi     temp, 8             ; Если не 9, продолжаем получать данные по UART
    breq    Stop_rx             ; Если 9, то запрещаем прерывания на прием, восст. знач. счетчика

Exit_rx:
    POP     temp                ; Восстанавливаем значение временных переменных
    out     SREG, temp          ;
    POP     temp1               ;
    POP     temp                ;
    reti

Stop_rx:
    ldi     temp, 0x00
    out     UCSRB, temp         ; Запрещаем прием/передачу, прерывания по переполнению
    ldi     temp, 0             ; Восстановление счетчика принятых байтов
    sts     count_rx_uart, temp ;
    cbi     PORTD, 3            ; Откл. светодиода индикации получения данных по UART
    
    rcall   Calc_co2                ; Вызов п/п сохранения значения СО2
    rjmp    Exit_rx

;===========================================================================================================
;Обработка прерывания по опустошению буфера UART
TX_UART:
    sbi     PORTD, 4            ; Вкл. светодиода индикаци передачи данных по UART
    PUSH    temp                ; Сохраняем значения временных переменных
    PUSH    temp1               ;
    in      temp, SREG		;
    PUSH    temp                ;

    lds     ZL, addr_uart_set   ; Загружаем адрес строки с командой чтения значения СО2
    lds     ZH, addr_uart_set+1 ;

    lpm     temp, Z+            ; Забираем значение по адресу индексного регистра с постинкриментом
    cpi     temp, 0xee          ; проверяем на символ окончания передачи
    breq    stop_tx             ; переход на п/п окончания передачи

    out     UDR, temp           ; Отправляем передаваемое значение в регистр
    sts     addr_uart_set, ZL   ; Сохраняем значение указателя на байт команды
    sts     addr_uart_set+1, ZH ;   

Exit_tx:   
    POP     temp                ; Восстанавливаем значение временных переменных
    out     SREG, temp          ;
    POP     temp1               ;
    POP     temp                ;
    reti

Stop_tx:
    lds     temp, flag_MH_init  ; Проверка на необходимость изменения диапазона измерения MH-Z19
    cpi     temp, 1             ; Если 1, то необходимо установить диапазон измерения
    breq    Range_set_co2       ; Переход на п/п передачи команды на установление диапазона

Stop_tx_2:
    ldi     temp, 0b10010000
    out     UCSRB, temp         ; Запрещаем передачу, прерывания по опустошению UDR
                                ; Разрешаем прерывания и прием данных по UART
    cbi     PORTD, 4            ; Откл. светодиода индикации передачи данных по UART
    rjmp    Exit_tx

Range_set_co2:
    ldi     temp, 0                    ;
    sts     flag_MH_init, temp         ; Обнуляем флаг необходимости задания диапазона измерения MH-Z19
    rjmp    Stop_TX_2                   ; 

;======================================================================================================
; Получение значения атмосферного давления от датчика LPS331AP по TWI, программная реализация протокола
Atm_Press:
    sbi     PORTB, 7               ; Включение светодиода индикации передачи данных по TWI
    rcall   Start_TWI              ; Старт на шину TWI

    lds     data_in_out, sad_w     ; Загружаем команду SAD+W в регистр РОН ввода/вывода
    rcall   TWI_Write
    rcall   Sak_TWI

    lds     data_in_out, twi_sub   ; Загружаем команду запроса адреса ячейки памяти SUB в РОН
    rcall   TWI_Write
    rcall   Sak_TWI
    rcall   Start_TWI    

    lds     data_in_out, sad_r     ; Загружаем команду SAD+R в регистр РОН ввода/вывода
    rcall   TWI_Write
    rcall   Sak_TWI
    rcall   TWI_Read
    rcall   Mak_TWI
    sts     press_twi, data_in_out    ; Сохранение 1-го принятого байта, линию SDA держать в "0" без тактовых импульсов

    rcall   TWI_Read
    rcall   Mak_TWI
    sts     press_twi+1, data_in_out  ; Cохранение второго принятого байта

    rcall   TWI_Read
    rcall   NMak_TWI                  ; Завершение получения данных от датчика LPS331AP 
    rcall   Stop_TWI                  ; 
    sts     press_twi+2, data_in_out  ; Cохранение третьего принятого байта

; ПРеобразование значения в BCD, пока без преобразования в мм.рт.ст. 
; В инструкции на датчик давл= (press_twi+2 & press_twi+1 & press_twi)/4096, т.е необходимо сдвинуть биты 12 раз,
; или press_twi+2 & press_twi+1 сдвигаем 4 раза.
    lds     fbinL, press_twi+1   ; Значение концентрации СО2 в регистры РОН для преобразования в BCD
    lds     fbinH, press_twi+2   ; Старший байт
    ldi     temp, 4              ; Для сдвига на 4 бита  

Twi_BCD_Loop:
    lsr     fbinH                  ; Деление на 4096, младшие биты отбрасываем
    ror     fbinL                  ; 
    dec     temp                   ; Декремент счетчика деления
    brne    Twi_BCD_Loop           ; Если счетчик больше 0, возвращаемся к началу цикла сдвига

TWI_to_BCD:
    rcall   Bin2BCD16              ; Переход на п/п преобразования числа в BCD
    sts     lpress, tBCD0          ; Сохранение упакованого в BCD значения
    sts     hpress, tBCD1          ; в переменных ОЗУ
    
    ldi     temp, 0b00000000        ; Цикл запроса данных от датчиков завершен
    sts     flag_ex_stage, temp     ; 

    cbi     PORTB, 7                ; Отключение светодиода индикации передачи данных по TWI
    rjmp    Main

; Пауза для обеспечения времени высокого/низкого уровня SCL 1,5 мкс
TWI_Pause:
    ldi     temp, 1                ; Должна получиться пауза 14 тактов
TWI_Pause_Loop:
    subi    temp, 1
    brne    TWI_Pause_Loop         ; Если результат предыдущ. операции не "0" отчет паузы не закончен
    ret

; Старт TWI: SDA в "1" -> 1.5 мкс -> SDA в "0" -> 1.5 мкс -> SCL в "0"
Start_TWI:
    sbi     PORTD, 6               ; SDA TWI в "1"
    sbi     PORTD, 2               ; SCL TWI в "1"
    rcall   TWI_Pause              ; Ждем 1.5 мкс
    cbi     PORTD, 6               ; Ставим вывод SDA TWI в "0"
    rcall   TWI_Pause              ; Подождали 1.5 мкс
    cbi     PORTD, 2               ; Линию тактового сигнала в "0"
    rcall   TWI_Pause
    ret

; Стоп TWI: линию тактового сигнала в "1", ждем 1.5 мкс, линию данных в "1"
Stop_TWI:
    cbi     PORTD, 6               ; SDA TWI в "0"
    rcall   TWI_Pause              ; 
    sbi     PORTD, 2               ; SCL TWI в "1"
    rcall   TWI_Pause              ; Ждем 1.5 мкс
    sbi     PORTD, 6               ; Ставим вывод SDA TWI в "0"
    rcall   TWI_Pause              ; 1.5 мкс
    ret

; Проверка ответа датчика по TWI. PORTD6 (SDA) на вход, SCL в "1", ждем 1,5 мкс, читаем состояние SDA
Sak_TWI:
    cbi     DDRD, 6              ; PD6 (SDA) на вход
    sbi     PORTD, 2             ; SCL в "1"
    rcall   TWI_Pause            ; Ждем 1,5 мкс
    sbic    PinD, 6              ; Читаем ответ SAK (передаваемый от LSP331AP)
    rjmp    Er_Sak               ; В PB5 "1"- переход на п\п обработки ошибки    
    cbi     PORTD, 2             ; Шину SCL в "0"
    rcall   TWI_Pause            ; ждем 1,5 мкс
    sbi     DDRD, 6              ; SDA на выход
    ret

; Обработка ошибки ответа от датчика LSP331AP
Er_Sak:
    ldi     fbinL, 0b00000001    ; Код ошибки: отсутствие ответа SAK от датчика
    ldi     fbinH, 0b00000000    ; Старший байт
    rjmp    TWI_to_BCD           ; Переход на п/п преобразования числа в BCD

; Ответ контроллера о получении байта
Mak_TWI:
    cbi     PORTD, 6             ; SDA в "0"
    sbi     DDRD, 6              ; SDA на выход
    rcall   TWI_Pause            ; Пауза 1,5 мкс
    sbi     PORTD, 2             ; SCL в "1"
    rcall   TWI_Pause            ; Пауза 1,5 мкс
    cbi     PORTD, 2             ; SCL в "0"
    rcall   TWI_Pause            ; Пауза 1,5 мкс
    ret

; Ответ контроллера о прекращении получения данных
NMak_TWI:
    sbi     PORTD, 6             ; SDA в "1"
    sbi     DDRD, 6              ; SDA на выход
    rcall   TWI_Pause            ; Пауза 1,5 мкс
    sbi     PORTD, 2             ; SCL в "1"
    rcall   TWI_Pause            ; Пауза 1,5 мкс
    cbi     PORTD, 2             ; SCL в "0"
    rcall   TWI_Pause            ; Пауза 1,5 мкс
    ret

; Передача байта по шине TWI
TWI_Write:   ; Бит на выход PD6 (SDA), затем поднимаем SCL (PD2), держим линию 1.5 мкс, опускаем SCL 
    ldi     tx_rx_count, 8      ; Количество передаваемых по USI бит
		
TX_TWI_Transfer_Loop:
    lsl     data_in_out          ; Старший бит в перенос
    brcc    TX_TWI_PUT_0         ; Если в переносе 0, то перейти на метку PUT_0
    sbi     PORTD, 6             ; В перносе 1 ставим высокий уровень PD6 (SDA)
    rjmp    TX_TWI_STROB                ; Переход к метке выдачи тактирующего строба

TX_TWI_PUT_0:
    cbi     PORTD, 6             ; В переносе 0, ставим низкий уровень PD6 (SDA)

TX_TWI_STROB:			
    rcall   TWI_Pause            ; Пауза 1,5 мкс после выставления состояния линии SDA
    sbi     PORTD, 2             ; Ставим  вывод тактового сигнала в 1
    rcall   TWI_Pause            ; Ждем 1,5 мкс для передачи бита
    cbi     PORTD, 2             ; Опускаем линию тактового сигнала
    rcall   TWI_Pause            ; Ждем 1,5 мкс 
    dec     tx_rx_count          ; Декремент счетчика передаваемого бита
    brne    TX_TWI_Transfer_Loop ; Если счетчик битов больше 0, возвращаемся к началу цикла передачи
    ret                          ; Возврат. Передача байта закончена 	

; Читаем данные от датчика
TWI_Read:
    ldi     tx_rx_count, 8       ; Количество принимаемых бит
    cbi     DDRD, 6              ; PB5 на вход

Rx_TWI_M1:
    sbi     PORTD, 2             ; Ставим  вывод тактового сигнала в 1
    rcall   TWI_Pause            ; Ждем 1,5 мкс для чтения состояния входа и получения бита
 
    sbic    PinD, 6              ; Читаем бит PD6 (передаваемый от LSP331AP бит)
    rjmp    Rx_TWI_1_bit_test    ; В PB5 "1"- переход на п\п установки "1" во флаг переноса SREG

    clc                          ; В переносе 0, записываем данные в РОН приема/передачи
    rol    data_in_out   
    rjmp   Rx_TWI_M2

Rx_TWI_1_bit_test:
    sec                          ; В PB3 "1"- ставим флаг переноса SREG в "1"
    rol    data_in_out    

Rx_TWI_M2:
    cbi     PORTD, 2             ; Опускаем линию тактового сигнала
    rcall   TWI_Pause            ; Ждем 1,5 мкс 
    dec     tx_rx_count          ; Декремент счетчика передаваемого бита
    brne    Rx_TWI_M1            ; Если счетчик битов больше 0, возвращаемся к началу цикла приема    

    cbi     PORTD, 2             ; Опускаем линию тактового сигнала
    rcall   TWI_Pause            ; Ждем 1,5 мкс 
    ret

; ===========================================================================================================
; Блок определения этапа выполнения связи с датчиком температуры DS18B20
Flag:
    rcall   Pause1                  ; Проверка на окончание периода между опросом датчиков

    lds     temp, flag_ex_stage     ; Проверка какой в данный момент этап выполняется
    sbrc    temp, 0                 ; Пропустить след команду, если настройку таймера Т1 выполнять не требуется
    rjmp    Timer1_Init_Temp        ; Переход на п/п настройки таймера Т1 для инициализации датчика DS18B20

    sbrc    temp, 2                 ; Проверка флага получения занчения атмосферного давления
    rjmp    Atm_Press               ;

    sbrc    temp, 3                 ; 
    rjmp    Pause_Temp_Conv         ; Бит установлен, переход на п/п ожидания преобразования температуры DS18B20

    sbrc    temp, 4                 ; Пропустить след команду, если настройку таймера Т1 выполнять не требуется
    rjmp    Timer1_Init_2_Temp      ; Переход на п/п настройки таймера Т1 для инициализации датчика DS18B20
    rjmp    Main

; ===========================================================================================================
; Таймер задержки проведения измерений (опроса датчиков)
Pause1:
    lds     temp, count1        ; Проверка окончания таймера между проведением измерением
    cpi     temp, 0

    breq    Temp_Measurement    ; Переход на подпрограмму работы с датчиком DS18B20
    ret 	

; =========================================================================================================
; Начало процедуры запроса измерения температуры и получения значения температуры от датчика DS18B20
Temp_Measurement:
    sbi     PORTB, 4                ; Вкл. питания датчика DS18B20
    lds     temp, delay1            ; Восстанавливаем значение счетчика для таймера задержки
    sts     count1, temp            ;

    ldi     temp, 0b00000001        ; Устанавливаем флаг в позицию начала инициализации
    sts     flag_ex_stage, temp     ; датчика температуры DS18B20
    ret

;==========================================================================================================
; Настройка таймера Т1 для инициализации DS18B20 (таймер 16 бит)
Timer1_Init:
    ldi    temp, 0xFE         ; Коэффициент для отсчета 496 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0x15        ;
    out    OCR1AH, temp       ; Записываем в регистр сравнения 1А таймера Т1
    out    OCR1AL, temp1      ;

    ldi    temp, 0xFE         ; Коэффициент для отсчета 560 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0x5B        ; 
    out    OCR1BH, temp       ; Записываем в регистр сравнения 1В таймера Т1
    out    OCR1BL, temp1      ;

    ldi    temp, 0xFC         ; Коэффициент для отсчета 1000 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0x17        ;
    out    TCNT1H, temp       ; Записываем в регистр сравнения 1С таймера Т1 (переполлнение таймера)
    out    TCNT1L, temp1      ;

    ldi    temp, 0xFF         ; Сбрасываем флаги совпадений
    out    TIFR, temp         ;
    sbi    DDRB, 3            ; Ставим PB3 на выход 
 
    ldi    temp, 0b00000010   ; Пуск таймера Т1 с предделителем 8 и отключенными прерываниями таймера Т1
    out    TCCR1B, temp       ;

Reset_Presence1:             ; Ожидание окончания сигнала сброса (496 мкс) для DS18B20
    in      temp, TIFR       ; Пропускаем следующую команду, если отсчет времени 496 мкс не закончен
    sbrs    temp, OCF1A      ; Проверяем отсутсвие наличия флага совпадения 1А таймера Т1
    rjmp    Reset_Presence1  ; Отсчет 496 мкс не закончен, возврат
    cbi     DDRB, 3           ; PB3 на вход

Reset_Presence2:             ; Ожидание окончания таймера до получения ответа от датчика DS18B20
    in      temp, TIFR       ; Пропуск следующей команды, если отсчет таймера 560 мкс до начала
    sbrs    temp, OCF1B      ; прослушивания ответа датчика температуры не закончился
    rjmp    Reset_Presence2  ; Отсчет 560 мкс от начала инициализации DS18B20 не закончен, возврат

    sbic    PinB, 3               ; Пропустить следующую команду, если на входе высокий уровень
    rjmp    Folt_Ans_Temp         ; Вызов подпрограммы установки флага отсутствия ответа от DS18B20
    
Reset_presence3:                  ; Ожидание окончания инициализации датчика DS18B20
    in      temp, TIFR            ; Пропуск следующей команды, если время ожидания окончания 
    sbrs    temp, TOV1            ; инициализации (1000 мкс) еще не закончился
    rjmp    Reset_presence3       ; Время одидания окончания инициализации не закончено, возврат

; Окончание инициализации, отключение таймера Т1
    ldi     temp, 0b00000000        ; Останавливаем таймер Т1
    out     TCCR1B, temp            ;
    ldi     temp, 0xFF              ; Сброс флагов в единицу
    out     TIFR, temp              ; Сбрасываем флаги совпадения счетчика таймера Т1: 1А, 1В, 1С
    ret

;===========================================================================================================
; Настройка таймера Т1 для передачи байта к датчику DS18B20
T1_Write_Ds18b20:
    ldi    temp, 0xFE         ; Коэффициент для отсчета 3 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0x03        ;
    out    OCR1AH, temp       ; Записываем в регистр сравнения 1А таймера Т1
    out    OCR1AL, temp1      ;

    ldi    temp, 0xFF         ; Коэффициент для отсчета 60 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0xD7        ;
    out    OCR1BH, temp       ; Записываем в регистр сравнения 1В таймера Т1
    out    OCR1BL, temp1      ; 

    ldi    temp, 0xFD         ; Коэффициент для отсчета 65 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0xF7        ;
    out    TCNT1H, temp        ; Записываем в регистр сравнения 1С таймера Т1
    out    TCNT1L, temp1      ;
    ret

;==========================================================================================================
;Настройка таймера Т1 для чтения байта от датчика DS18B20
T1_Read_Ds18b20:
    ldi    temp, 0xFd         ; Коэффициент для отсчета 2 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0xff        ;
    out    OCR1AH, temp       ; Записываем в регистр сравнения 1А таймера Т1
    out    OCR1AL, temp1      ;

    ldi    temp, 0xFE         ; Коэффициент для отсчета 10 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0x0b        ;
    out    OCR1BL, temp       ; Записываем в регистр сравнения 1В таймера Т1
    out    OCR1BH, temp1      ;

    ldi    temp, 0xFD         ; Коэффициент для отсчета 65 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0xF7        ;
    out    TCNT1L, temp        ; Записываем в регистр сравнения 1С таймера Т1
    out    TCNT1H, temp1      ;
    ret

; ===========================================================================================================
; Настройка таймера/счетчика Т1 для инициализации датчика температуры DS18B20
Timer1_Init_Temp: 
    sbi    PORTD, 5           ; Вкл. светодиода индикации обмена данными по 1-Wire
    rcall  Timer1_Init        ; Вызов п/п для инициализации датчика температуры    
    rcall  T1_Write_Ds18b20   ; Вызов п/п настройки таймера Т1 для передачи байта к DS18B20

; Передача команды пропуск идентификации
Tx_Byte_skip_ident:                     
    ldi    tx_rx_count, 8               ; Устанавливаем счетчик переданных битов
    lds    data_in_out, tx_skip_ident   ; Передаем команду пропуск идентификации датчика
    rcall  Tx_Byte_Loop                 ; Вызов подпрограммы передачи байта    

; Передача команды к DS18B20 на выполнение измерения
Tx_Byte_Start_Conv:                      
    ldi     tx_rx_count, 8               ; Устанавливаем счетчик переданных битов
    lds     data_in_out, tx_start_conv   ; Передаем команду пропуск идентификации датчика
    rcall   Tx_Byte_Loop                 ; Вызов подпрограммы передачи байта    
    cbi     PORTD, 5                     ; Откл. светодиода индикации обмена данными по 1-Wire
                               
; Настройка таймера Т1 для ожидания окончания измерения датчиком
    ldi     temp, 0b10000010   ; Разрешены прерывания от таймера Т1
    out     TIMSK, temp        ;

    ldi     temp, 0b00000001   ; Пуск таймера Т1 без предделителя, с коэффициентом 122 (counter2)
    out     TCCR1B, temp       ; задержка ~1 сек.

; Запуск передачи данных по UART к датчику MH-Z19
    lds     temp, flag_MH_init  ; Проверка на необходимость изменения диапазона измерения MH-Z19
    cpi     temp, 1             ; Если 1, то необходимо установить диапазон измерения
    breq    addr_set_co2       ; Переход на п/п установки адреса установки диапазона MHZ19

    ldi     temp, low(2*MHZ_co2_read)    ;  Сохраняем значение адреса в переменной ОЗУ
    ldi     temp1, high(2*MHZ_co2_read)  ;
    sts     addr_uart_set, temp         ;
    sts     addr_uart_set+1, temp1      ;
    rjmp    RX_Init

addr_set_co2:
    ldi     temp, low(2*MHZ_range_set)   ;  Сохраняем значение адреса в переменной ОЗУ
    ldi     temp1, high(2*MHZ_range_set) ;
    sts     addr_uart_set, temp         ;
    sts     addr_uart_set+1, temp1      ;

RX_Init:
    ldi     temp, 0b00101000
    out     UCSRB, temp         ; Разрешаем передачу, прерывания по опустошению UDR

    ldi     temp, 0b000001000     ; Устанавливаем флаг в позицию ожидания окончания преобразования 
    sts     flag_ex_stage, temp   ; датчиком температуры DS18B20
    rjmp    Main

; ===========================================================================================================
; Обработка события отсутствия ответа от датчика температуры
Folt_Ans_Temp:
    ldi     temp, 0xFF              ; Сбрасываем флаги записью единиц
    out     TIFR, temp              ; Сбрасываем флаги совпадения счетчика таймера Т1: 1А, 1В, 1С
    cbi     PortD, 5                ; Отключение светодиода передачи данных по 1-Wire

; Запуск передачи данных по UART к датчику MH-Z19
    ldi     temp, 0b00101000
    out     UCSRB, temp         ; Разрешаем передачу, прерывания по опустошению UDR

    ldi     temp, 0b000001000      ; Устанавливаем флаг в позицию ожидания окончания преобразования 
    sts     flag_ex_stage, temp   ; датчиком температуры DS18B20
    rjmp    Main

; ==========================================================================================================
; Проверка окончания работы таймера ожидания окончания измерения датчиком температуры
Pause_Temp_Conv:
    lds     temp, count2        ; Проверка окончания таймера между проведением измерением
    cpi     temp, 0

    breq    End_Pause_Temp_Conv ; Переход на п/п чтения значения температуры от DS18B20
    rjmp    Main	
    
End_Pause_Temp_Conv:
    ldi     temp, 0b00000010        ; Запрещаем прерывания таймера Т1
    out     TIMSK, temp             ;

    ldi     temp, 0x00              ; Останавливаем таймер Т1
    out     TCCR1B, temp             ;
    ldi     temp, 0xFF              ; Сброс флагов в единицу
    out     TIFR, temp              ; Сбрасываем флаги совпадения счетчика таймера Т1: 1А, 1В, 1С

    lds     temp, delay2            ; Восстанавливаем значение коэфф. 2 задержки 2
    sts     count2, temp            ;
   
    ldi     temp, 0b00010000        ; Устанавливаем флаг в позицию начала инициализации 2
    sts     flag_ex_stage, temp     ; датчика температуры DS18B20 и передачи запроса получение данных
    rjmp    Main

; =========================================================================================================== 
; Подпрограмма передачи байта
Tx_Byte_Loop:
    ldi    temp, 0xFD         ; Коэффициент для отсчета 65 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0xF7        ;
    out    TCNT1H, temp       ; Записываем в регистр сравнения 1С таймера Т1
    out    TCNT1L, temp1      ;
   
    ldi    temp, 0b00000001   ; Пуск таймера Т1 с предделителем 8 и отключенными прерываниями таймера Т1
    out    TCCR1B, temp       ;
    sbi    DDRB, 3            ; PB3 на выход
   
Tx_bit_Loop: 
    in      temp, TIFR       ; Пропускаем следующую команду, если отсчет времени 3 мкс не закончен
    sbrs    temp, OCF1A      ; Проверяем отсутсвие наличия флага совпадения 1А таймера Т1
    rjmp    Tx_bit_Loop      ; Если таймер импульса восстановления не закончился, возвращяемся к началу цикла

    lsr     data_in_out	     ; Младший бит в перенос
    brcc    Tx_M1            ; Если в переносе 0, то ничего не делаем и переходим на метку Tx_M1
    cbi     DDRB, 3          ; PB3 высокий уровент

Tx_M1:
    in      temp, TIFR       ; Пропуск следующей команды, если отсчет таймера 40 мкс генерации "0",
    sbrs    temp, OCF1B      ; или "1" не завершился
    rjmp    Tx_M1            ; Если таймер генерации бита не закончился, возврат к началу цикла
    cbi     DDRB, 3          ; Ставим PB3 в высокий уровень до окончания слота времени (импульс восстановления)

Tx_M2:
    in      temp, TIFR       ; Пропуск следующей команды, если отсчет таймера 65 мкс не закончился
    sbrs    temp, TOV1       ; (окончание слота времени на передачу бита)
    rjmp    Tx_M2            ; Если таймер слота времени не закончился, возврат к началу цикла
    
    ldi     temp, 0b00000000 ; Останавливаем таймер Т1
    out     TCCR1B, temp     ;
    ldi     temp, 0xFF       ; Сбрасываем флаги совпадений
    out     TIFR, temp       ; Сбрасываем флаги совпадения счетчика таймера Т1: 1А, 1В, 1С

    dec     tx_rx_count      ; Декремент счетчика передаваемого бита
    brne    Tx_Byte_Loop     ; Если счетчик битов больше 0, возвращаемся к началу цикла передачи байта
    ret                      ; Возврат 	

; ==========================================================================================================
; Подпрограмма получения байта
Rx_Byte_Loop:
    ldi    temp, 0xFD         ; Коэффициент для отсчета 65 мкс при делителе 8 и частоте МК 8 МГц
    ldi    temp1, 0xF7        ;
    out    TCNT1H, temp       ; Записываем в регистр сравнения 1С таймера Т1
    out    TCNT1L, temp1      ;
   
    ldi    temp, 0b00000001   ; Пуск таймера Т1 с предделителем 8 и отключенными прерываниями таймера Т1
    out    TCCR1B, temp       ;
    sbi    DDRB, 3            ; Переключаем PB3 на низкий уровень
   
Rx_bit_Loop: 
    in      temp, TIFR       ; Пропускаем следующую команду, если отсчет времени 3 мкс не закончен
    sbrs    temp, OCF1A      ; Проверяем отсутсвие наличия флага совпадения 1А таймера Т1
    rjmp    Rx_bit_Loop      ; Если таймер импульса восстановления не закончился, возвращяемся к началу цикла
    cbi     DDRB, 3          ; PB3 на вход

Rx_M1:
    in      temp, TIFR       ; Пропуск следующей команды, если отсчет таймера 40 мкс одидания ответа от
    sbrs    temp, OCF1B      ; датчика температуры не закончился
    rjmp    Rx_M1            ; Если таймер ожидания получаемого бита не закончился, возврат к началу цикла

    sbic    PinB, 3         ; Читаем бит PB3 (передаваемый от DS18B20 бит)
    rjmp    Rx_1_bit_test   ; В PB3 "1"- переход на п\п установки "1" во флаг переноса SREG
    
    clc 
    ror    data_in_out   
    rjmp   Rx_M2

Rx_1_bit_test:
    sec                      ; В PB3 "1"- ставим флаг переноса SREG в "1"
    ror    data_in_out    

Rx_M2:
    in      temp, TIFR       ; Пропуск следующей команды, если отсчет таймера 65 мкс не закончился
    sbrs    temp, TOV1       ; (окончание слота времени на передачу бита)
    rjmp    Rx_M2            ; Если таймер слота времени не закончился, возврат к началу цикла
    
    ldi     temp, 0b00000000 ; Останавливаем таймер Т1
    out     TCCR1B, temp      ;
    ldi     temp, 0xFF       ; Сбрасываем флаги совпадений
    out     TIFR, temp       ; Сбрасываем флаги совпадения счетчика таймера Т1: 1А, 1В, 1С

    dec     tx_rx_count      ; Декремент счетчика принимаемого бита
    brne    Rx_Byte_Loop     ; Если счетчик битов больше 0, возвращаемся к началу цикла передачи байта
    ret                      ; Возврат 	

; ==========================================================================================================
; Настройка таймера/счетчика Т1 для повторной инициализации датчика температуры DS18B20
Timer1_Init_2_Temp: 
    sbi    PORTD, 5           ; Вкл. светодиода передачи данных по 1-Wire
    rcall  Timer1_Init        ; Вызов п/п инициализации DS18B20
    rcall  T1_Write_Ds18b20   ; Вызов п/п настройки таймера Т1 для передачи байта к DS18B20

; Передача команды пропуск инициализации
    ldi    tx_rx_count, 8               ; Устанавливаем счетчик переданных битов
    lds    data_in_out, tx_skip_ident   ; Передаем команду пропуск идентификации датчика

    rcall  Tx_Byte_Loop                 ; Вызов подпрограммы передачи байта    

; Передача команды чтения блокнота DS18B20
    ldi    tx_rx_count, 8               ; Устанавливаем счетчик переданных битов
    lds    data_in_out, tx_request_temp ; Передаем команду чтения блокнота

    rcall  Tx_Byte_Loop       ; Вызов подпрограммы передачи байта    
    rcall  T1_Read_Ds18b20    ; Вызов п/п настройки таймера Т1 для чтения байта от DS18B20

; Чтение блокнота датчика температуры DS18B20
    ldi     tx_rx_count, 8            ; Устанавливаем счетчик принятых битов
    rcall   Rx_Byte_Loop              ; Вызов п/п получения младшего байта значения температуры
    sts     ltemperature, data_in_out ; Сохраняем младший байт

    ldi     tx_rx_count, 8            ; Устанавливаем счетчик принятых битов
    rcall   Rx_Byte_Loop              ; Вызов п/п получения старшего байта значения температуры
    sts     htemperature, data_in_out ; Сохраняем старший байт
    cbi     PORTD, 5                  ; Откл. светодиода индикации передачи данных по 1-Wire
    cbi     PORTB, 4                  ; Откл. питания датчика температуры DS18B20

    ldi     temp, 0b00000100        ; Переход к этапу запроса значения атмосферного давления
    sts     flag_ex_stage, temp     ;
    rjmp    Neg_temp

;=======================================================================================================
; Извлечение значения концентрации СО2 из переменной rx_uart_mhz, расчет концентрации и сохранение в ОЗУ
; На данном этапе без обработки сразу преобразование в BCD.
Calc_co2:
    lds     temp, rx_uart_mhz+3           ; Значение содержания СО2 в РОН
    lds     temp1, rx_uart_mhz+2          ;
    mov     fbinl,temp 
    mov     fbinh, temp1

    rcall   Bin2BCD16              ; Переход на п/п преобразования числа в BCD
    sts     lco2, tBCD0            ; Сохранение упакованого в BCD значения
    sts     hco2, tBCD1            ;

    lds     temp, choice_ind    ; Проверка что выводим на экран в данном цикле
    cpi     temp, 0x00          ; Если 0, то присваиваем 1
    breq    Set_1               ; Переход на п/п присвоения значения 0
    ldi     temp, 0x00          ; Если не 0, присваиваем 0
    sts     choice_ind, temp
    rjmp    End_set_choice

Set_1:
    ldi     temp, 0xFF
    sts     choice_ind, temp    

End_set_choice:
    ret

; =======================================================================================================
; Сохранение в переменной знака "-" при отрицательном значении температуры
Neg_Temp:
    lds     temp, htemperature     ; Проверка на отрицательное значение температуры
    sbrc    temp, 7                ; Если бит установлен в "1", значит темп. отрицательная
    rjmp    Convert_Neg_Temp       ; Переход на подпрограмму преобразования из дополнительного кода

    ldi     temp, 0x00             ; Для положительной температуры обнуляем значения индикатора
    sts     indication_sign, temp  ; На индикаторе знака ничего не отображается
    rcall   Integer_Value          ; Переход на п/п перемещения целой части значения в один байт

    lds     temp, integer_temp     ;
    mov     fbinL, temp            ; Запись целой части температуры для преобр. в BCD

    rcall    Bin2BCD16             ; Переход на п/п преобразования числа в BCD
    sts      integer_temp, tBCD0   ; Сохраняем упакованное значение температуры для хранения
    rjmp     Main                  ; Переход к чтению значения АЦП (от датчика СО2)

Convert_Neg_Temp:
    lds     temp, negative_temp    ; Записываем код знака минус в переменную для индикации
    sts     indication_sign, temp  ;
    rcall   Integer_Value          ; Переход на п/п перемещения целой части значения в 1 байт

    lds     temp, integer_temp     ; Преобразование в положительное число
    neg     temp                   ; целой части значения температуры
    mov     fbinL, temp            ; Записываем знач. целой части темп. в перем. для преобр. в BCD
    ldi     fbinH, 0x00            ; Старший байт  для преобразования int temp в BCD
    rcall   Bin2BCD16              ; Переход на п/п преобразования числа в BCD
    sts     integer_temp, tBCD0    ; Сохраняем упакованное значение температуры для хранения
    rjmp     Main                  ; Все измерения завершены, возврат в главный цикл

; ========================================================================================================
; Сохранение целой части значения температуры в 1 байте (результат разместить в integer_temp)
Integer_Value:
    lds     temp, ltemperature     ; Перемещение значения целой части температуры в один байт
    swap    temp                   ; Меняем полубайты младшего байта местами
    andi    temp, 0x0F             ; Обнуляем старший полубайт
    lds     temp1, htemperature    ; Старший байт во временный регистр
    swap    temp1                  ; Меняем полубайты старшего байта занчения температуры местами
    andi    temp1, 0xF0            ; Обнуляем младший полубайт старшего байта
    or      temp, temp1            ; Складываем полубайты целого значения темп. в один байт
    sts     integer_temp, temp     ; Сохраняем целую часть значения темп. в одном байте
    ret    

; ===========================================================================================================
; Subroutine bin 16 bit to BCD 
Bin2BCD16:
    ldi     cnt16a, 16          ; Init loop counter
    clr     tBCD2               ; Clear result 3 bytes
    clr     tBCD1               ;
    clr     tBCD0               ;
    clr     ZH                  ; Clear ZH

bBCDx_1:
    lsl     fbinL               ; Shift input value
    rol     fbinH               ; Through all bytes
    rol     tBCD0               ;
    rol     tBCD1               ;
    rol     tBCD2               ;
    dec     cnt16a              ; Decrement loop counter
    brne    bBCDx_2             ; If counter not zero
    ret                         ; Return

bBCDx_2:
    ldi     r30, AtBCD2 + 1     ; Z points to result MSB + 1

bBCDx_3:
    ld      tmp16a, -Z          ; Get (Z) with pre- decrement
    subi    tmp16a, -0x03       ; Add 0x03
    sbrc    tmp16a, 3           ; if bit 3 not clear
    st      Z, tmp16a           ; Store back
    ld      tmp16a, Z           ; Get (Z)
    subi    tmp16a, -0x30       ; Add 0x30
    sbrc    tmp16a, 7           ; If bit 7 not clear
    st      Z, tmp16a           ; Store back
    cpi     ZL, AtBCD0          ; Done all three?
    brne    bBCDx_3             ; Lopp again if not
    rjmp    bBCDx_1             ; 

; ==========================================================================================================
; Передачи измеренных значений на индикатор (сначала передаются значения содержания СО2, затем темп.
Decoder_BCD:
    ldi     temp, 0b10000000    ; Восстанавливаем значение счетчика включаемого индикатора
    sts     led_counter, temp   ;

    lds     temp, lco2          ; Данные для распаковки значенияы BCD0 
    rcall   Unpacking_BCD       ; Вызов подпрограммы распаковки BCD0
    rcall   Transfer_BCD        ; Вызов подпрограммы для передачи значения BCD0
	
    lds     temp, hco2          ; Данные для распаковки значения  BCD1
    rcall   Unpacking_BCD       ; Вызов подпрограммы для распаковки BCD1
    rcall   Transfer_BCD        ; Вызов подпрограммы для передачи значения BCD1

    lds     temp, choice_ind    ; Проверка что выводим на экран в данном цикле
    cpi     temp, 0x00          ; Если 1, то выводим значение атм. давления
    breq    Ind_temp            ; Переход на п/п передачи команды на установление диапазона

    lds     temp, lpress        ; Данные для распаковки значенияы BCD0 
    rcall   Unpacking_BCD       ; Вызов подпрограммы распаковки BCD0
    rcall   Transfer_BCD        ; Вызов подпрограммы для передачи значения BCD0
	
    lds     temp, hpress        ; Данные для распаковки значения  BCD1
    rcall   Unpacking_BCD       ; Вызов подпрограммы для распаковки BCD1
    rcall   Transfer_BCD        ; Вызов подпрограммы для передачи значения BCD1
    rjmp    End_indication

Ind_temp:
    lds     temp, integer_temp  ; Выведение на индикатор целой части значения температуры
    rcall   Unpacking_BCD       ;
    rcall   Transfer_BCD        ;

End_indication:
    rcall   Led_Off
    ret

; =======================================================================================================
; Гасим предыдущий индикатор для исключения паразитного свечения
Led_Off:
    ldi     data_in_out, 0x00
    rcall   SPI_Transfer                 ;
    sbi     PORTB, 1            ; Ставим защелку сдвигового регистра в 1 для фиксации значения
    cbi     PORTB, 1            ; Формируем отрицательный импульс на защелку сдвиг. регистра
; Обнуляем значения обоих сдвиговых регистров    
    rcall   SPI_Transfer                 ;
    sbi     PORTB, 1            ; Ставим защелку сдвигового регистра в 1 для фиксации значения
    cbi     PORTB, 1            ; Формируем отрицательный импульс на защелку сдвиг. регистра
    ret

;=========================================================================================================
Transfer_BCD:
    lds     temp, ldigit        ; Записываем первое передаваемое значение для декодированиия
    sts     digit, temp         ;
    rcall   Decoder             ; Вызов подпрограммы декодирования и передачи значения в USI
	
    lds     temp, hdigit        ; Записываем второе передаваемое значение для декодирования
    sts     digit, temp         ;
    rcall   Decoder             ; Вызов подпрограммы декодирования и передачи значения в USI
    ret

; ===========================================================================================================
; Извлечение упакованного в BCD значения. Вход 8 бит, выход 2 значения для 7-сегм. индикатора
; Вход через temp, выход r22:r21
Unpacking_BCD:
    mov     temp1, temp          ; Отделяем из BCD младший полубайт
    andi    temp1, 0x0F          ; 
    sts     ldigit, temp1        ;

    mov     temp1, temp          ; Отделяем из BCD старший полубайт
    andi    temp1, 0xF0          ;
    swap    temp1                ; Меняем полубайты местами
    sts     hdigit, temp1        ; Младший и старший полубайты в ldigit и hdigit
    ret

; =============================================================================================================
; Подпрограмма кодирования передаваемого на семисегментный индикатор числа
Decoder:
    rcall   Led_Off
    rcall   Led_On              ; Вызов подпрограммы для передачи значения включаемого индикатора

    ldi     ZH, HIGH (N_Mask*2) ; Загружаем адрес начала маски кода числа для семисегм. индикатора
    ldi     ZL, LOW (N_MASK*2)  ;
    lds     temp, digit         ; 
    add     zl, temp            ; Прибавляем к адресу начала маски адрес значения счетчика
    lpm	                        ;
    mov     data_in_out, r0     ; Значение в регистре r0

    rcall   SPI_Transfer        ; Вызов подпрограммы передачи в SPI
	
    sbi     PORTB, 1            ; Ставим защелку сдвигового регистра в 1 для фиксации значения
    cbi     PORTB, 1            ; Формируем отрицательный импульс на защелку сдвиг. регистра
    rcall   Led_On_Pause        ; Пауза для увеличения времени свечения индикатора
    ret                         ; Возврат

; =============================================================================================================
; Подпроограмма для определения какой включаем индикатор
Led_On:
    lds     data_in_out, led_counter    ; Загружаемм байт с позицией включаемого индикатора
    rcall   SPI_Transfer                ; Вызов подпрограммы для передачи байта с позицией вкл. индикатора

    lds     temp, led_counter           ; Передаем код включения необходимого индикатора
    lsr     temp                        ; Сдвигаем бит влево для включения в следующем цикле очередного индик
    sts     led_counter, temp           ; Сохраняем значение до следующего раза
    ret

;==============================================================================================================
; Пауза для увеличения времени свечения сегментов индикаторов
Led_On_Pause:
    ldi     temp, 100 
Led_On_Pause_Loop:
    subi    temp, 1
    brne    Led_On_Pause_Loop        ; Если отчет паузы не закончен, переход к началу цикла
    ret

; ===============================================================================================================
; Подпрограмма передачи данных на индикатор по прерыванию счетчика таймера
SPI_Transfer:
    ldi     tx_rx_count, 8      ; Количество передаваемых по USI бит
		
SPI_Transfer_Loop:
    lsl     data_in_out		; Старший бит в перенос
    brcc    PUT_0               ; Если в переносе 0, то перейти на метку PUT_0
    sbi     PORTB, 0            ; В перносе 1 ставим высокий уровень PB0 (MOSI)
    rjmp    STROB               ; Переход к метке выдачи тактирующего строба

PUT_0:
    cbi     PORTB, 0            ; В переносе 0, ставим низкий уровень PB0 (MOSI)

STROB:			
    sbi     PORTB, 2            ; Ставим  вывод тактового сигнала в 1
    cbi     PORTB, 2            ; Ставим вывод тактового сигнала в 0
    dec     tx_rx_count         ; Декремент счетчика передаваемого бита
    brne    SPI_Transfer_Loop   ; Если счетчик битов больше 0, возвращаемся к началу цикла передачи
    ret                         ; Возврат 	
